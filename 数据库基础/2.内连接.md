# 多表检索

## 1.内连接

INNER JOIN（INNER 可省）

FROM 表A JOIN 表B ON AB 将哪几张表以什么基础链接/合并起来

```sql
USE sql_store;

SELECT 
	order_id,
    oi.product_id,
    name,
    quantity,
    oi.unit_price
FROM order_items oi
JOIN products p
	ON oi.product_id = p.product_id
```

## 2.跨数据库链接

需要选取非当前库的表的列，需要在该表的前面加上库名前缀

```sql
USE sql_store;

SELECT *
FROM order_items oi
JOIN sql_inventory.products p
 ON oi.product_id=p.product_id
```

## 3.自连接

一个表和自己合并。如员工的上级也是员工，因此也在员工表中，想要得到员工和他的上级的合并表，就要员工表和自己合并，**用两个不同的表别名即可实现**

```sql
USE sql_hr;

SELECT e.employee_id,
	e.first_name,
    m.first_name as manager
FROM employees e
JOIN employees m
	on e.reports_to=m.employee_id
```

<img src="../../assets/image-20220821105413548.png" alt="image-20220821105413548" style="zoom: 80%;" />

## 4.多表连接

FROM 一个主A，用多个JOIN……ON……分别通过不同的链接关系链接不同的表B、C、D……，通常是让表B、C、D……为表A提供更详细的信息，从而合并为一张详情合并版 A表

**案例:**

订单表同时链接顾客表和订单状态表，合并为有顾客和状态信息的详细订单表

```sql
USE sql_store;

SELECT 
	o.order_id,
	o.order_date,
    c.first_name,
    c.last_name,
    os.name as status
FROM orders o
JOIN customers c
	on c.customer_id=o.customer_id
JOIN order_statuses os
	on os.order_status_id=o.status
```

## 5.复合连接条件

FROM 表1 JOIN 表2 ON 条件1 **AND** 条件2

```sql
USE sql_store;

SELECT * 
FROM order_items oi 
JOIN order_item_notes oin
	ON oin.order_Id =oi.order_id
    AND oi.product_id=oin.product_id
```

**注意：AND 后面直接加条件，不用再写ON**

## 6.隐式连接语法

就是用FROM WHERE取代FROM JOIN ON

尽量别用，因为**若忘记WHERE条件筛选语句，不会报错但会得到交叉合并（cross join）结果**：即10条order会分别与10个customer结合，得到100条记录。最好使用显性合并语法，因为会强制要求你写合并条件ON语句，不至于漏掉。

```sql
USE sql_store;

SELECT * 
FROM orders o
JOIN customers c
    ON o.customer_id = c.customer_id
```

隐式连接

```sql
SELECT * 
FROM orders o, customers c  
WHERE o.customer_id = c.customer_id
```

注意 FROM 子句里的逗号，就像 SELECT 多条列用逗号隔开一样，FROM 多个表也用逗号隔开，此时若忘记WHERE条件筛选语句则得到这几张表的交叉合并结果

## 7.外连接

注意：

（INNER) JOIN 结果只包含两表的交集

LEFT/RIGHT (OUTER) JOIN 结果里除了交集，还包含只出现在左/右表中的记录

**案例**

合并顾客表和订单表，用INNER JOIN：

合并顾客表和订单表，用 INNER JOIN：

```sql
USE sql_store;

SELECT 
    c.customer_id,
    c.first_name,
    o.order_id
FROM customers c
JOIN orders o
    ON o.customer_id = c.customer_id
ORDER BY customer_id
```

这样是INNER JOIN，只展示有订单的顾客（及其订单），也就是两张表的交集，但注意这里因为一个顾客可能有多个订单，所以INNER JOIN以后顾客信息其实是是广播了的，即一条顾客信息被多条订单记录共用，当然 这叫广播（broadcast）效应，是另一个问题，这里关注的重点是 INNER JOIN 的结果确实是两表的交集，是那些同时有顾客信息和订单信息的记录。

<img src="../../assets/image-20220821115206035.png" alt="image-20220821115206035" style="zoom:67%;" />

<img src="../../assets/image-20220821115232154.png" alt="image-20220821115232154" style="zoom:67%;" />

若要展示全部顾客（及其订单，如果有的话），要改用LEFT (OUTER) JOIN，结果相较于 INNER JOIN 多了**没有订单**的那些顾客，即只有顾客信息没有订单信息的记录（包含部分空值），上图是普通内连接与左外连接的结果差别

当然，也可以调换左右表的顺序（即调换FROM和JOIN的对象）再 RIGHT JOIN，即：

```sql
FROM orders o
    RIGHT [OUTER] JOIN customers c
    -- 中括号 [] 表示是可选项、可省略 
    ON o.customer_id = c.customer_id
```

若要展示全部订单（及其顾客），就应该是 orders RIGHT JOIN customers，结果相较于 `INNER JOIN` 多了没有顾客的那些订单，即只有订单信息没有顾客信息的记录。（注：因为这里所有订单都有顾客，所以这里 RIGHT JOIN 结果和 INNER JOIN 一样）

## 8.多表外连接