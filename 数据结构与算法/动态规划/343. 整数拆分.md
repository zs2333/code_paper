#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

示例 1:

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

示例 2:

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```


提示:

2 <= n <= 58

**思路：核心在于如何实现拆分，通过动态规划实现拆分，主要通过两个步骤**

假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：

1) 将 i 拆分成 j 和 i−j 的和，且 i−j **不再拆分成多个**正整数，此时的乘积是 j * (i-j)
1) 将 i 拆分成 j 和 i−j 的和，且 i−j **继续拆分**成多个正整数，此时的乘积是 j * dp[i-j]

其实就是比较拆两个与拆多个的值取更大的。与此同时还要保留上次循环的最大值

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        #注意这里为什么要是n+1呢？因为需要使得指针坐标与实际的n相符，这样方便统一进行加减乘除运算
        #初始化的时候不考虑dp[0]与dp[1]
        dp=[0]*(n+1)
        dp[2]=1

        for i in range(3,n+1):
            for j in range(i):
                dp[i]=max(dp[i],max(j*(i-j),dp[i-j]*j))

        return dp[-1]
```

